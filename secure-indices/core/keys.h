#ifndef KEYS_H__
#define KEYS_H__

#include "fss-core/DCF-source/DCFClient.h"
#include "fss-core/DCF-source/DCFServer.h"
#include "fss-core/DPF-source/DPFClient.h"
#include "fss-core/DPF-source/DPFServer.h"
#include <cryptoTools/Crypto/PRNG.h>
#include <stdlib.h>     /* srand, rand */
#include <time.h>       /* time */

// typedef unsigned __int128 bgi_uint128_t;

namespace dorydb{

    using namespace osuCrypto;
    // client key
    class clkey{
        public:
            bool malicious = false;
            // DPF
            // convert vectors to block* using vector.ref()
            block* dpf_key0;
            block* dpf_key1;
            uint128_t* dpf_g0;
            uint128_t* dpf_g1;

            block* dpf_mac_key0;
            block* dpf_mac_key1;
            uint128_t* dpf_mac_g0;
            uint128_t* dpf_mac_g1;
            uint64_t dpf_size = 0;
            // DCF
            block* dcf_key0;
            block* dcf_key1;
            uint128_t* dcf_v0;
            uint128_t* dcf_v1;
            block* dcf_mac_key0;
            block* dcf_mac_key1;
            uint128_t* dcf_mac_v0;
            uint128_t* dcf_mac_v1;
            uint64_t dcf_size = 0;
            
            // random gen
            block seed;
            PRNG prng;
            
            clkey();
            ~clkey();
            void dpf_generate(uint128_t punctured_x, uint128_t payload, uint64_t depth, uint64_t gout_bitsize, bool use_modulus = true, uint128_t modulus = 0, bool malicious = false, uint128_t alpha = 0);
            void dcf_generate(uint128_t punctured_x, uint128_t payload, uint64_t depth, uint64_t gout_bitsize, bool use_modulus = true, uint128_t modulus = 0, bool greaterThan = false, bool strictlyGT = false, bool malicious = false, uint128_t alpha = 0);
            // return total #bytes of the keys generated by client.
            uint64_t get_keysize();
            void dcf_serialize(uint64_t depth, uint8_t *key0, uint8_t *key1);
            void dpf_serialize(uint64_t depth, uint8_t *key0, uint8_t *key1);
    };

    // server key
    class svkey{
        public:
            bool init = false;
            bool malicious = false;
            // Role here can only be EVAL0 or EVAL1
            uint8_t role = 255;
            // DPF
            block* dpf_key;
            uint128_t* dpf_g;
            block* dpf_mac_key;
            uint128_t* dpf_mac_g;
            uint64_t dpf_size = 0;
            // DCF
            block* dcf_key;
            uint128_t* dcf_v;
            block* dcf_mac_key;
            uint128_t* dcf_mac_v;
            uint64_t dcf_size = 0;
            
            svkey(bool malicious = false);
            ~svkey();
            uint64_t get_keysize();
            uint128_t dcf_eval(uint128_t input_x, uint64_t depth, uint64_t gout_bitsize, bool use_modulus = true, uint128_t modulus = 0);
            void dcf_eval(uint128_t res, uint128_t input_x, uint64_t depth, uint64_t gout_bitsize, bool use_modulus = true, uint128_t modulus = 0);
            // Naive version
            void dcf_evalfull(uint128_t* res, uint64_t depth, uint64_t gout_bitsize, bool use_modulus = true, uint128_t modulus = 0);
            // Optimized version
            void dpf_eval_contig(uint128_t* res, uint64_t depth, uint64_t start, uint64_t end, uint64_t gout_bitsize, bool use_modulus, uint128_t modulus, bool malicious_run = false);
            void dcf_eval_contig(uint128_t* res, uint64_t depth, uint64_t start, uint64_t end, uint64_t gout_bitsize, bool use_modulus, uint128_t modulus, bool malicious_run = false);
            void dcf_deserialize(uint64_t depth, const uint8_t *key);
            void dpf_deserialize(uint64_t depth, const uint8_t *key);
    };
}

#endif
